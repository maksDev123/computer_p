# computer_p
Аналіз зв’язності графів

Виконали: Максим Булешний, Юстина Бас, Володимир Бронецький, Петро Прокопець, Тимофій Тарасенко


Завдання №1
Читання графу з файлу 

Простим графом називають пару G=(V, E), де V – непорожня скінченна множина елементів, названих вершинами, E – множина невпорядкованих пар різних елементів з V. Елементи множини E (невпорядковані пари різних вершин) називають ребрами. 
Функція відкриває файл, повертає всі рядки файлу як список та створює список ребер. Потім перетворює всі числа рядків на цілі і перетворює список ребер в словник.

Завдання №2
Запис графу у файл

Функція записує граф у файл.

Завдання №3
Пошук компонент зв’язності 

Функція повинна знаходити усі компоненти зв'язності неорієнтованого графу і повертати список компонент зв'язності.
Ми використовували функцію пошуку в глибину, щоб допомогти нам знайти всі вузли зв’язності.
Спочатку ми беремо список вузлів у точному компоненті зв’язності, додаємо вузол зв’язності до списку, який ми будемо повертати. Видаляємо всі вузли зв’язності, щоб підготувати його до виконання функції пошуку вшир та повертаємо результат.

Завдання №4
Функція пошуку компонент сильної зв'язності для орієнтованого графу.

Орієнтований граф — граф , ребрам якого присвоєно напрямок. Результатом  буде список, який містить мінімальну вершину для сильно зв'язного компоненту. obhid — це список, який містить позицію вершини або -1, якщо вершина не була відвідана. Low — це список, який містить значення нижчих посилань кожної вершини або -1, якщо ця вершина не була виявлена.
Stack - підтримує дійсні версії для scc. Якщо verices раніше не відвідували, запускаємо сценарій recur_scc (dfs). Якщо всі версії відвідано, повертає результат.
Рекурсивно:
Додаємо ідентифікатор до obhid. Ініціалізуємо нижнє значення посилання вершини. Додаємо вершини до stack дійсних вершин. Проходимо через кожну сусідню вершину. Якщо наступна вершина не відвідана, ми відвідаємо її та візьмемо мінімальні значення нижнього посилання. Якщо наступна вершина знаходиться в stack, ми беремо мінімальне значення низького зв’язку поточної вершини та ідентифікатора сусідньої вершини. Якщо вершина є головою підграфа, ми беремо всі вершини перед нею в stack та беремо мінімум із них. Беремо вершину з вершини  та stack видаляємо її.



Завдання №5
Пошук точок сполучення - знаходить усі точки сполучення неорієнтованого графу (повертає список вершин).

Створюємо новий словник, щоб зберігати в ньому відредаговані графи. Створюємо список у якому ми будемо зберігати вершини з'єднання. Створюємо змінну, яка зберігатиме кількість компонентів графа.
 Робимо цикл, який повторює ключі словника (вершини) та цикл, який повторює ключові змінні та видаляє вершину з графа. Якщо після видалення вершини кількість компонентів змінилася, то ми додаємо цю вершину до списку. Потім повертаємо графу колишній вміст. Перевіряємо, чи список порожній та повертаємо список вершин з'єднання.

Завдання №6
Пошук мостів - знаходить усі мости неорієнтованого графу.

Створюємо копії даного графа і створюємо необхідні змінні. Спочатку, ітерація циклу для перетворення даного графа в кортеж із ребрами.  Потім ми створили модуль для запобігання циклічної залежності, наприклад (2,3) і (3,2) та модуль для перевірки, чи є ребро мостом чи ні. Перевіряємо чи зв'язний без цієї компоненти граф. Потім, deep copy нового графіка, щоб спробувати алгоритм з іншим ребром. Якщо в графі немає мостів, то повертаємо None. В кінці повертаємо список з мостами.


Розподіл роботи:
1, 2, 3 функції - Петро Прокопець
4 функція - Максим Булешний
5, 6 функції - Володимир Бронецький, Тимофій Тарасенко
Звіт та презентація - Бас Юстина 
